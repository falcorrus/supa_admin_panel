[[вайб-кодинг]]

Пример для вставки как инструкции в LLM
```
Пошаговый процесс:

   1. Пользовательский интерфейс (UI):
       * На странице "Настройки" у вас уже есть форма "Добавить новое подключение". Пользователь,
         вошедший в систему, вводит в нее свои данные: Название, URL, anon_key и service_role_key.

   2. Вызов Edge Function (Вместо прямого сохранения в базу):
       * Когда пользователь нажимает "Сохранить", ваш React-компонент не выполняет
         supabase.from('connections').insert(...).
       * Вместо этого он делает fetch-запрос к специальной Edge Function, которую вы создадите,
         например, /api/save-connection.
       * В теле этого запроса передаются введенные пользователем данные (URL, ключи и т.д.).
       * Supabase автоматически прикрепляет к этому запросу заголовок Authorization с JWT-токеном
         пользователя, так что Edge Function будет знать, кто именно к ней обратился.

   3. Работа Edge Function на сервере (самое главное):
       * a. Аутентификация и Авторизация: Первым делом функция проверяет токен и получает ID
         пользователя (const { data: { user } } = await supabase.auth.getUser()). Если пользователь
          не аутентифицирован, функция немедленно возвращает ошибку. Теперь сервер точно знает, для
          какого пользователя нужно сохранить ключ.
       * b. Шифрование: Функция извлекает ваш мастер-ключ из Supabase Vault (секретных переменных
         окружения). Она никогда не получает его от клиента. Затем она использует этот мастер-ключ
         для шифрования anon_key и service_role_key, которые пришли от пользователя.
       * c. Безопасное сохранение в базу: Функция выполняет upsert (обновление или вставку) в вашу
         таблицу connections в основной базе. Ключевой момент — она добавляет или обновляет запись,
          привязанную к ID пользователя.
           * Например: supabase.from('connections').upsert({ user_id: user.id, name: 'Моя новая
             база', encrypted_service_key: '...' }).
           * Это гарантирует, что пользователь A никогда не сможет перезаписать данные пользователя
              B.

   4. Двойная защита с помощью Row Level Security (RLS):
       * В качестве дополнительного и очень мощного уровня защиты вы настраиваете RLS-политики на
         таблице connections в вашей основной базе.
       * Политика будет звучать так: "Пользователь может видеть, изменять или удалять записи в
         таблице connections только в том случае, если значение в колонке user_id этой записи
         совпадает с его собственным ID (auth.uid())".
       * Даже если в коде Edge Function будет какая-то ошибка, RLS на уровне базы данных не
         позволит одному пользователю получить доступ к данным другого.

  Обновленная схема

  Поток №1: Сохранение ключа

    1 [Пользователь вводит ключ в форму]
    2        |
    3        v
    4 [React-приложение] ---> (1. Вызывает Edge Function `/api/save-connection` с ключами в теле
      запроса)
    5        |
    6        v
    7 [Edge Function "save-connection"]
    8        |
    9        | (2. Получает user_id из токена)
   10        | (3. Шифрует ключи мастер-ключом из Vault)
   11        | (4. Сохраняет зашифрованные данные в таблицу `connections` с user_id)
   12        v
   13 [Основная база Supa (с RLS)]

  Поток №2: Доступ к данным (остается без изменений)

    1 [Пользователь хочет получить данные]
    2        |
    3        v
    4 [React-приложение] ---> (1. Вызывает Edge Function `/api/tenant-proxy` с запросом "дай
      заказы")
    5        |
    6        v
    7 [Edge Function "tenant-proxy"]
    8        |
    9        | (2. Получает user_id из токена)
   10        | (3. Находит нужную запись в `connections` по user_id)
   11        | (4. Расшифровывает ключ на сервере)
   12        | (5. Делает запрос к базе тенанта)
   13        v
   14 [База данных Тенанта] ---> (6. Возвращает данные)
   15        |
   16        v
   17 [Edge Function "tenant-proxy"] ---> (7. Пересылает данные клиенту)
   18        |
   19        v
   20 [React-приложение]

  Итог

  Таким образом, вы получаете лучшее из двух миров:
   1. Удобство для пользователя: Тенанты могут самостоятельно и в любое время управлять своими
      подключениями.
   2. Высокая безопасность: Все секреты по-прежнему управляются на сервере, и клиент никогда не
      имеет к ним прямого доступа. Вы защищены на уровне логики приложения (в Edge Function) и на
      уровне базы данных (через RLS). 
```
      